import heapq


# jobs : [(요청 시점, 소요 시간), ]
def solution(jobs):
    time = 0 # 총 소요 시간
    now = 0 # 현재 시점
    start = -1 # 현재 작업의 시작 시간
    i = 0
    heap = [] # 처리할 작업 저장 힙

    while i < len(jobs):
        for job in jobs:
            if start < job[0] <= now: # start가 필요한 이유는 이전에 실행한 job을 거르기 위함
                heapq.heappush(heap, (job[1], job[0])) # 작업 시간이 짧은 순으로 정렬하기 위해 순서를 바꿔줌

        if heap: # 처리할 수 있는 작업이 있을 때
            job = heapq.heappop(heap)
            start = now # 현재 작업의 시작 시간
            now += job[0] # 작업 소요 시간 (현재 시간 + 소요 시간)
            time += now - job[1] # 총 소요 시간
            i += 1
        else: # 현재 시점에 처리할 수 있는 작업이 없을 때
            now += 1

    return time // len(jobs)

# print(solution([[0, 3], [1, 9], [2, 6]]))
print(solution([[7, 8], [3, 5], [9, 6]]))


'''
- 평균을 가장 줄이는 방법은 요청이 가장 먼저 오는 것 중에 작업 시간이 짧은 순으로 진행한다.
    - 현재 처리 가능하면 힙에 담는다.
        - 현재 처리 가능하다는 것은 작업 요청이 이미 들어와 있는 것. 즉, 요청 시점이 현재 시점보다 작거나 같고 현재 작업의 시작 시간보다 커야한다.
        - 힙에 담을 때는 요청이 가장 먼저오는 것을 걸렀으니 작업 시간이 짧은 순으로 정렬해야 한다. (요청 시간이 같은 작업이 있을 수 있음)
    - 현재 시점에 처리할 수 있는 작업이 없으면 시간이 흘러야 한다. 플러스 1초
    - 처리할 수 있는 작업이 있을 때 now는 해당 작업이 종료된 시점이 되고, 소요 시간은 (작업 종료 시점 - 요청 시점)이 된다.
- i는 job의 길이만큼 반복하고 while문을 빠져나오기 위한 용도
'''